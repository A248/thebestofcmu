/*
 * thebestofcmu
 * Copyright Â© 2022 Anand Beh
 *
 * thebestofcmu is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * thebestofcmu is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with thebestofcmu. If not, see <https://www.gnu.org/licenses/>
 * and navigate to version 3 of the GNU Affero General Public License.
 */

use eyre::Result;
use std::time::{Duration, SystemTime};
use sqlx::{Connection, PgPool, query, Row};
use thebestofcmu_common::{ClientRSVP, Invitee, RsvpDetails, ServerResponse};

pub struct Database {
    pub pool: PgPool
}

impl Database {
    pub async fn create_schema(&self) -> Result<()> {
        let mut connection = self.pool.acquire().await?;
        query(r#"
        CREATE TABLE IF NOT EXISTS "invited" (
          "id" INT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
          "first_name" VARCHAR(32) NOT NULL,
          CONSTRAINT "first_name_uniqueness" UNIQUE ("first_name")
        );
        "#).execute(&mut connection).await?;
        query(r#"CREATE TABLE IF NOT EXISTS "rsvps" (
          "first_name" INT NOT NULL,
          "phone_no" BIGINT NULL,
          "email_address" VARCHAR(128) NULL,
          "time_registered" BIGINT NOT NULL,
          CONSTRAINT "first_name_uniqueness" UNIQUE ("first_name"),
          CONSTRAINT "first_name_integrity" FOREIGN KEY ("first_name") REFERENCES "invited" ("id")
        );
        "#).execute(&mut connection).await?;
        Ok(())
    }

    pub async fn insert_invite(&self, first_name: &str) -> Result<()> {
        let mut connection = self.pool.acquire().await?;
        query(r#"
        INSERT INTO "invited" ("first_name") VALUES (?)
        "#)
            .bind(first_name)
            .execute(&mut connection)
            .await?;
        Ok(())
    }

    pub async fn select_invites(&self) -> Result<Vec<Invitee>> {
        let mut connection = self.pool.acquire().await?;
        let results = query(r#"
        SELECT "invites"."id", "invites"."first_name",
        "rsvps"."phone_no", "rsvps"."email_address", "rsvps"."time_registered"
        FROM "invites" LEFT JOIN "rsvps" ON "invites"."id" = "rsvps"."first_name"
        "#)
            .fetch_all(&mut connection)
            .await?;
        results.into_iter()
            .map(|row| {
                let rsvp = if let Some(time_registered) = row.get::<Option<i64>, _>("time_registered") {
                    Some((
                        RsvpDetails {
                            phone_number: row.get("phone_no"),
                            email_address: row.get("email_address")
                        },
                        SystemTime::UNIX_EPOCH + Duration::from_secs(time_registered as u64)
                    ))
                } else {
                    None
                };
                Ok(Invitee {
                    id: row.get("id"),
                    first_name: row.get("first_name"),
                    rsvp
                })
            })
            .collect()
    }

    pub async fn insert_rsvp(&self, rsvp: ClientRSVP) -> Result<ServerResponse> {

        let time_since_epoch = std::time::SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)?
            .as_secs();

        let mut connection = self.pool.acquire().await?;
        let mut connection = connection.begin().await?;
        let invited_id = query(r#"
        SELECT "id" FROM "invited" WHERE "first_name" = ?
        "#)
            .bind(rsvp.first_name)
            .fetch_optional(&mut connection)
            .await?;

        Ok(if let Some(row) = invited_id {
            let invited_id: i32 = row.get("id");
            let existing_rsvp = query(r#"
            SELECT "time_registered" FROM "rsvps" WHERE "first_name" = ?
            "#)
                .bind(invited_id)
                .fetch_optional(&mut connection)
                .await?;

            if let Some(existing_rsvp) = existing_rsvp {
                let time_registered = existing_rsvp.get::<i64, _>("time_registered");
                ServerResponse::AlreadyRSVPed(time_registered as u64)
            } else {
                query(r#"
                INSERT INTO "rsvps" ("first_name", "phone_no", "email_address", "time_registered")
                VALUES (?, ?, ?, ?)
                "#)
                    .bind(invited_id)
                    .bind(rsvp.details.phone_number)
                    .bind(rsvp.details.email_address)
                    .bind(time_since_epoch as i64)
                    .execute(&mut connection)
                    .await?;
                connection.commit().await?;

                ServerResponse::Success
            }
        } else {
            ServerResponse::NotInvited
        })
    }
}
